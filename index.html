<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ワンピカ相性表メーカー</title>
    <!-- html2canvasライブラリをインポートし、画像保存を可能にします -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-text: #e0e0e0;
            --border-color: #444;
            --header-bg: #333;
            --cell-size: 60px;
            --accent-blue: #0d6efd;
            --accent-green: #198754;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 1rem;
            background-color: var(--bg-color);
            color: var(--primary-text);
            font-size: 16px;
        }
        .container { max-width: 900px; margin: 0 auto; }
        .config-section, .chart-section, .controls {
            background-color: var(--surface-color);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            margin-bottom: 1.5rem;
        }
        h1, h2 { color: #f5f5f5; }
        h1 { text-align: center; margin-bottom: 1.5rem; }
        h2 { margin-top: 0; font-size: 1.3rem; border-bottom: 2px solid var(--header-bg); padding-bottom: 0.5rem; }
        .char-count-form { display: flex; gap: 10px; align-items: center; }
        .char-count-form input {
            flex-grow: 1; padding: 10px; border: 1px solid #555;
            background-color: var(--header-bg); color: var(--primary-text);
            border-radius: 8px; font-size: 1rem;
        }
        .char-count-form button {
            padding: 10px 20px; border: none; background-color: var(--accent-blue); color: white;
            border-radius: 8px; font-size: 1rem; font-weight: bold; cursor: pointer;
        }
        #chart-wrapper { width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch; }
        #chart-container { display: inline-grid; border-top: 1px solid var(--border-color); border-left: 1px solid var(--border-color); margin-top: 1rem; }
        .grid-cell {
            width: var(--cell-size); height: var(--cell-size);
            display: flex; justify-content: center; align-items: center;
            border-right: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color);
            box-sizing: border-box; background-color: #2a2a2a;
            position: relative;
        }
        .header-text { background-color: var(--header-bg); font-weight: bold; font-size: 0.8rem; padding: 2px; text-align: center; }
        .char-icon-slot, .data-cell { font-size: 1.8rem; font-weight: bold; cursor: pointer; }
        .char-icon-slot img { width: 100%; height: 100%; object-fit: cover; }
        .data-cell.disabled { background-color: #444; cursor: not-allowed; }
        .win-rate-cell { font-size: 0.9rem; font-weight: bold; background-color: #4a3c00; color: #ffdf7c; }
        .other-cell { background-color: var(--header-bg); }
        .distribution-input {
            width: 100%; height: 100%; border: none; text-align: center;
            font-size: 1rem; font-weight: bold; background-color: #2c3e50; color: #fff;
        }
    .distribution-select { width: 100%; height: 100%; border: none; background: #2c3e50; color: #fff; font-weight: bold; text-align: center; }
    .distribution-select option { background: #2c3e50; color: #fff; }
    .distribution-label { font-size: 0.85rem; color: #ddd; margin-left: 6px; }
        #dist-total { font-weight: bold; }
        #dist-total.error { color: #ff6b6b; }
        .controls button {
            width: 100%; padding: 0.8rem; font-size: 1.1rem; border: none; border-radius: 8px;
            color: white; cursor: pointer; font-weight: bold; background-color: var(--accent-green);
        }
        /* Row layout for primary actions (save / tweet) */
        .action-row { display:flex; gap:10px; }
        .action-row > button, .action-row > .twitter-share-button {
            flex: 1 1 0; display: inline-flex; align-items: center; justify-content: center;
            padding: 0.95rem 1.2rem; font-size: 1.15rem; border-radius: 10px; text-decoration: none; color: white;
            font-weight: 700; border: none; cursor: pointer; min-height: 48px;
        }
        .action-row > button { background-color: var(--accent-green); }
    .action-row > .twitter-share-button { background-color: #1da1f2; }
    /* Slightly increase Twitter button prominence while preserving shape */
    .twitter-share-button { box-shadow: 0 2px 6px rgba(29,161,242,0.12); }
        .twitter-share-button:hover { opacity: 0.95; }
        /* Larger / native-feel styles for data-size="large" */
        .twitter-share-button[data-size="large"] {
            background: linear-gradient(180deg,#1da1f2,#1a91da);
            padding: 0.85rem 1.1rem; font-size: 1.15rem; border-radius: 10px; min-height: 48px;
            box-shadow: 0 6px 18px rgba(29,161,242,0.12);
        }
        .twitter-share-button[data-size="large"] svg { color: #fff; }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center;
            z-index: 1000;
        }
        .modal-overlay.visible { display: flex; }
        .modal-content {
            background: #333; padding: 1.5rem; border-radius: 12px;
            /* Center the 3 top items and balance with 4 bottom items */
            display: grid;
            grid-template-columns: 1fr 1.2fr 1.2fr 1fr;
            grid-auto-rows: 64px;
            gap: 10px;
            max-width: 560px;
            justify-items: center;
            align-items: center;
        }
        /* Character select specific horizontal layout */
        .char-select-content {
            display: flex;
            flex-direction: row;
            gap: 18px;
            align-items: flex-start;
            max-width: 720px;
        }
        .char-select-left { flex: 1 1 auto; }
        .char-select-right { display:flex; align-items:center; justify-content:center; min-width:160px; }
        .horizontal-grid { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

        /* Responsive: stack vertically on narrow viewports */
        @media (max-width: 640px) {
            .char-select-content { flex-direction: column; max-width: 92vw; }
            .char-select-right { min-width: auto; width: 100%; }
            .horizontal-grid { justify-content: center; }
        }
        .modal-options-grid { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; }
    .modal-option { padding: 6px 10px; background: #2f2f2f; color: #fff; border-radius: 8px; cursor: pointer; min-width: 56px; text-align: center; border: 1px solid rgba(255,255,255,0.06); display:flex; flex-direction:column; align-items:center; justify-content:center; }
    .modal-option:hover, .modal-option:focus { background: #3f3f3f; transform: translateY(-2px); outline: 2px solid rgba(13,110,253,0.18); }
    .modal-option:active { transform: scale(0.96); }
        #preset-char-grid { max-height: 200px; overflow-y: auto; padding-right: 10px; }
        .preset-char-icon { width: 50px; height: 50px; border-radius: 8px; overflow: hidden; cursor: pointer; border: 2px solid #555; }
        .preset-char-icon:hover { border-color: var(--accent-blue); }
        .preset-char-icon img { width: 100%; height: 100%; object-fit: cover; }
        #upload-from-modal-btn {
            padding: 10px; background-color: var(--accent-blue); color: white;
            border: none; border-radius: 8px; font-weight: bold; cursor: pointer;
        }
        .icon-legend {
            display: flex; justify-content: center; flex-wrap: wrap;
            gap: 1rem; margin-top: 1.5rem; padding-top: 1rem;
            border-top: 1px solid var(--border-color); font-size: 0.9rem;
        }
        .legend-item { display: flex; align-items: center; gap: 0.5rem; }
        .legend-item span:first-child { font-size: 1.5rem; }
        .hidden { display: none; }
    </style>
</head>
<body>
<div class="container">
    <h1>ワンピカ相性表メーカー</h1>
    <div id="site-admin" style="text-align:center;margin-top:6px;margin-bottom:14px;color:#cbd5c9;font-size:0.95rem;">管理人: <a href="https://twitter.com/kelvee_eeevee" target="_blank" rel="noopener" style="color:#9fe1ff;text-decoration:none;">@kelvee_eevee</a></div>
    <main>
        <div class="config-section">
            <h2>キャラクター数を指定</h2>
            <div class="char-count-form">
                <select id="char-count-input">
                    <!-- default 4 -->
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4" selected>4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                    <option value="11">11</option>
                    <option value="12">12</option>
                    <option value="13">13</option>
                    <option value="14">14</option>
                    <option value="15">15</option>
                </select>
                <button id="create-chart-btn">表を再作成</button>
            </div>
        </div>
        <div id="chart-section" class="chart-section">
            <div class="distribution-header">
                 <h2>分布と相性を入力</h2>
                 <div id="dist-total">合計分布: 0%</div>
            </div>
            <div id="chart-wrapper"><div id="chart-container"></div></div>
            <div id="icon-legend" class="icon-legend"></div>
        </div>
        <div id="controls" class="controls">
             <h2>操作</h2>
            <div class="action-row">
                <button id="save-btn">画像として保存</button>
                <!-- Twitter-style share button (large) - keep anchor so widgets.js can enhance it but include inner structure so it looks correct without the script -->
                <a id="tweet-btn" href="#" class="twitter-share-button" role="button" aria-label="ツイート" data-size="large">
                    <!-- Inline bird + text so the button looks native even before widgets.js runs -->
                    <span style="display:inline-flex;align-items:center;gap:8px;">
                        <svg aria-hidden="true" viewBox="0 0 24 24" width="18" height="18" fill="currentColor" style="filter: drop-shadow(0 1px 0 rgba(0,0,0,0.15));">
                            <path d="M22.46 6c-.77.35-1.6.58-2.46.69a4.3 4.3 0 0 0 1.88-2.37 8.6 8.6 0 0 1-2.72 1.04 4.28 4.28 0 0 0-7.3 3.9A12.14 12.14 0 0 1 3.15 4.6a4.28 4.28 0 0 0 1.32 5.71c-.66-.02-1.28-.2-1.82-.5v.05c0 2.1 1.5 3.85 3.5 4.25-.34.1-.7.15-1.07.15-.26 0-.5-.03-.74-.07.5 1.6 2 2.77 3.76 2.8A8.58 8.58 0 0 1 2 19.54a12.1 12.1 0 0 0 6.56 1.92c7.88 0 12.2-6.53 12.2-12.2v-.56A8.72 8.72 0 0 0 22.46 6z"/>
                        </svg>
                        <span style="font-weight:700;">ツイート</span>
                    </span>
                </a>
            </div>
        </div>
    </main>
</div>

<!-- 相性選択モーダル -->
<div id="matchup-modal" class="modal-overlay"><div class="modal-content modal-options-grid"></div></div>
<!-- キャラ選択モーダル (横長レイアウトに復元) -->
<div id="char-select-modal" class="modal-overlay">
    <div class="modal-content char-select-content">
        <div class="char-select-left">
            <h3>キャラクターを選択</h3>
            <!-- horizontal-grid を使ってアイコンを横並びに表示 -->
            <div id="preset-char-grid" class="horizontal-grid"></div>
            <!-- アップロードボタンをアイコンの下に配置 -->
            <div style="width:100%; display:flex; justify-content:center; margin-top:12px;">
                <button id="upload-from-modal-btn" style="width:92%;">画像をアップロード</button>
            </div>
        </div>
    </div>
</div>

<input type="file" id="image-upload-input" class="hidden" accept="image/*">

<script>
    document.addEventListener('DOMContentLoaded', () => {
    // Expanded compatibility map: 13 choices from 20% to 80% by 5%
    const COMPATIBILITY_MAP = {
        '80': 80, '75': 75, '70': 70, '65': 65, '60': 60, '55': 55, '50': 50,
        '45': 45, '40': 40, '35': 35, '30': 30, '25': 25, '20': 20
    };
    // Display emoji/symbol for each percent key. When emojis are not unique enough
    // we show the numeric percent under the emoji in the UI.
    const ICON_DISPLAY = {
        '80': '☆', '75': '☆', '70': '◎', '65': '◎', '60': '◯', '55': '◯', '50': 'ー',
        '45': '△', '40': '△', '35': '▲', '30': '▲', '25': '×', '20': '×'
    };
    // Keys sorted descending by percent so modal shows highest to lowest
    const ICONS = Object.keys(COMPATIBILITY_MAP).sort((a,b) => Number(b) - Number(a));
    const DEFAULT_KEY = '50';
    const DEFAULT_SYMBOL = 'ー';
    
    // プリセット画像のURLリスト（ローカルimgフォルダのファイルを使用）
    const PRESET_IMAGES = [
        'img/赤青エース.png', 'img/黒イム.png', 'img/緑ゾロ.png', 'img/赤紫ロジャー.png', 
        'img/赤緑ルフィ.png',  'img/赤黒サボ.png', 'img/青紫ルフィ.png',
        'img/赤レイリー.png', 'img/赤黄ベティ.png', 'img/緑ボニー.png', 
    ];

    // ===== デフォルトキャラクター設定 =====
    // ここの配列を編集すると、起動時に表示されるキャラクターと分布が変わります。
    const DEFAULT_CHARACTERS = [
        { src: PRESET_IMAGES[0], distribution: 20 },
        { src: PRESET_IMAGES[1], distribution: 20 },
        { src: PRESET_IMAGES[2], distribution: 20 },
        { src: PRESET_IMAGES[3], distribution: 15 }
    ];
    // ===================================

    let state = {};
    let currentEdit = {};

    const getEl = id => document.getElementById(id);
    const charCountInput = getEl('char-count-input');
    const createChartBtn = getEl('create-chart-btn');
    const chartContainer = getEl('chart-container');
    const matchupModal = getEl('matchup-modal');
    const charSelectModal = getEl('char-select-modal');
    const imageUploadInput = getEl('image-upload-input');
    const distTotalEl = getEl('dist-total');
    const saveBtn = getEl('save-btn');
    const legendContainer = getEl('icon-legend');
    const uploadFromModalBtn = getEl('upload-from-modal-btn');

    // Show a visible warning if the page is opened via file:// which often causes
    // html2canvas/cors/canvas security errors. Advise running a local HTTP server.
    function showFileProtocolWarningIfNeeded() {
        try {
            if (location && location.protocol === 'file:') {
                const existing = document.getElementById('security-warning');
                if (existing) return;
                const warn = document.createElement('div');
                warn.id = 'security-warning';
                warn.style.background = '#3c2b2b';
                warn.style.color = '#ffd';
                warn.style.padding = '10px 14px';
                warn.style.borderRadius = '8px';
                warn.style.margin = '0 0 12px 0';
                warn.style.fontSize = '0.95rem';
                warn.innerHTML = '<strong>注意:</strong> このページをファイルとして直接開いています。ブラウザのセキュリティにより画像生成が失敗することがあります。' +
                    '<br>ページをローカルHTTPサーバーで配信してから再試行してください。例（PowerShell / コマンドプロンプト）:' +
                    '<pre style="margin:6px 0 0;background:#222;padding:8px;border-radius:6px;color:#fff;">python -m http.server 8000</pre>' +
                    '<div style="opacity:0.9;margin-top:6px;">その後ブラウザで <code>http://localhost:8000/</code> を開いてください。</div>';
                const container = document.querySelector('.container');
                if (container) container.insertBefore(warn, container.firstChild);
            }
        } catch (e) { /* ignore */ }
    }

    createChartBtn.addEventListener('click', () => {
        const count = parseInt(charCountInput.value, 10);
        if (count > 0 && count <= 15) {
            initializeState(count);
            renderChart();
        } else {
            alert('1から15までの数値を入力してください。');
        }
    });

    imageUploadInput.addEventListener('change', e => {
        if (!e.target.files[0]) return;
        const reader = new FileReader();
        reader.onload = event => {
            if (currentEdit.type === 'icon') {
                state.icons[currentEdit.index] = event.target.result;
                charSelectModal.classList.remove('visible');
                renderChart();
            }
        };
        reader.readAsDataURL(e.target.files[0]);
    });
    
    matchupModal.addEventListener('click', e => { if (e.target === matchupModal) matchupModal.classList.remove('visible'); });
    charSelectModal.addEventListener('click', e => { if (e.target === charSelectModal) charSelectModal.classList.remove('visible'); });
    uploadFromModalBtn.addEventListener('click', () => imageUploadInput.click());

    // Helper: convert a Blob to a data:URL
    function blobToDataURL(b) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onerror = () => reject(new Error('FileReader failed'));
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(b);
        });
    }

    // Embed external images found within a cloned DOM node by fetching them and replacing src with data URLs.
    // Only attempts to convert remote http(s) images. Relative/local and data: URLs are left as-is.
    async function embedExternalImages(rootElement) {
        const imgs = Array.from(rootElement.querySelectorAll('img'));
        await Promise.all(imgs.map(async (img) => {
            const src = img.getAttribute('src') || img.src || '';
            if (!/^(https?:)?\/\//i.test(src)) return; // skip data: and relative/local paths
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 7000);
                const res = await fetch(src, { mode: 'cors', signal: controller.signal });
                clearTimeout(timeoutId);
                if (!res.ok) return;
                const blob = await res.blob();
                const dataUrl = await blobToDataURL(blob);
                img.src = dataUrl;
            } catch (e) {
                // ignore failures; leave original src which may taint the canvas
            }
        }));
    }

    // Capture the full chart and return a blob (PNG)
    async function captureFullChart() {
        const original = getEl('chart-section');
        const clone = original.cloneNode(true);

        const offscreen = document.createElement('div');
        offscreen.style.position = 'fixed';
        offscreen.style.left = '-99999px';
        offscreen.style.top = '0';
        offscreen.style.background = getComputedStyle(original).backgroundColor || '#fff';
        offscreen.appendChild(clone);
        document.body.appendChild(offscreen);

    // Replace the header/title text in the clone so saved image shows project title
    const headerEl = clone.querySelector('.distribution-header h2');
    if (headerEl) headerEl.textContent = 'ワンピカ相性表メーカー';
    // Add watermark text to the cloned header area so it's present only in the exported image
    try {
        const watermark = document.createElement('div');
        watermark.textContent = '@kelvee_eevee';
        watermark.style.position = 'absolute';
        watermark.style.right = '12px';
        watermark.style.top = '8px';
        watermark.style.fontSize = '14px';
        watermark.style.fontWeight = '700';
        watermark.style.color = '#ffffff';
        watermark.style.opacity = '0.95';
        watermark.style.background = 'rgba(0,0,0,0.25)';
        watermark.style.padding = '4px 8px';
        watermark.style.borderRadius = '8px';
        watermark.style.pointerEvents = 'none';
        watermark.style.zIndex = '9999';
        // Place watermark inside the cloned header container if present, otherwise inside the clone
        const headerContainer = clone.querySelector('.distribution-header') || clone;
        headerContainer.style.position = headerContainer.style.position || 'relative';
        headerContainer.appendChild(watermark);
    } catch (e) { /* ignore */ }

    // Try to embed any external images found in the clone to reduce CORS/taint risks
    await embedExternalImages(clone);

    const imgs = Array.from(clone.querySelectorAll('img'));
    await Promise.all(imgs.map(img => {
            if (img.complete) return Promise.resolve();
            return new Promise(resolve => { img.onload = img.onerror = resolve; });
        }));

        const wrapper = clone.querySelector('#chart-container') || clone;
        wrapper.style.width = wrapper.scrollWidth + 'px';
        wrapper.style.height = wrapper.scrollHeight + 'px';

        const scale = Math.max(1, window.devicePixelRatio || 1);
        try {
            const canvas = await html2canvas(clone, {
                backgroundColor: getComputedStyle(original).backgroundColor || '#1e1e1e',
                scale: scale,
                useCORS: true
            });
            return await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
        } finally {
            document.body.removeChild(offscreen);
        }
    }

    // Existing save button now uses captureFullChart
    saveBtn.addEventListener('click', async () => {
        try {
            const blob = await captureFullChart();
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'aishou-hyou.png';
            link.href = url;
            link.click();
            setTimeout(() => URL.revokeObjectURL(url), 5000);
        } catch (err) {
            alert('画像の保存に失敗しました: ' + (err && err.message ? err.message : err));
        }
    });

    // Tweet button: try to upload image to Imgur (optional) then open Twitter intent with text+url+hashtag
    // Delegate clicks on the tweet anchor so we remain robust if Twitter's widgets.js replaces the node.
    document.addEventListener('click', async (evt) => {
        const anchor = evt.target.closest ? evt.target.closest('#tweet-btn') : null;
        if (!anchor) return;
        evt.preventDefault();

        // Generate image blob
        let blob;
        try {
            blob = await captureFullChart();
        } catch (err) {
            const msg = (err && err.message) ? err.message : String(err);
            // Detect common security/insecure error and show actionable instructions
            if (/insecure/i.test(msg) || (err && err.name === 'SecurityError')) {
                alert('画像の生成に失敗しました: ブラウザのセキュリティ制限の可能性があります。\n\n' +
                    'このページを直接（file://）で開いている場合は、ローカルHTTPサーバーで配信して再試行してください。\n\n' +
                    '例（PowerShell / コマンドプロンプト）：\npython -m http.server 8000\n\n' +
                    'その後ブラウザで http://localhost:8000/ を開いてください。');
                // Also show in-page warning to help the user
                showFileProtocolWarningIfNeeded();
                return;
            }
            alert('画像の生成に失敗しました: ' + msg);
            return;
        }

        // Open Twitter intent with the page URL (Imgur upload removed)
        const text = encodeURIComponent('相性表を作成しました！ #ワンピカ相性表メーカー');
        const pageUrl = encodeURIComponent(window.location.href);
        const twitterUrl = `https://twitter.com/intent/tweet?text=${text}&url=${pageUrl}`;
        window.open(twitterUrl, '_blank');
    });

        // NOTE: intentionally not loading platform.twitter.com/widgets.js by default.
        // The widgets script will rewrite/replace the anchor and insert a platform-specific
        // widget (in your environment it produced a small pill-like button). To keep the
        // custom large bird+label button that matches the '保存' control, we avoid loading
        // the widgets script. If you later want the official Twitter/X widget, we can
        // make this opt-in.

    function initializeState(count) {
        // count引数がある場合（再作成ボタン）は、以前のロジックで新しい表を作成
        if (count) {
            // Auto-fill icons from PRESET_IMAGES and evenly distribute percentages
            state = { charCount: count, icons: {}, distributions: {}, matchups: {}, otherMatchups: {} };
            // Fill icons in order from PRESET_IMAGES (wrap if necessary)
            for (let i = 0; i < count; i++) {
                state.icons[i] = PRESET_IMAGES[i % PRESET_IMAGES.length];
            }
            // Evenly distribute 100% across characters; other becomes 0
            const base = Math.floor(100 / count);
            let remainder = 100 - base * count;
            for (let i = 0; i < count; i++) {
                state.distributions[i] = base + (remainder > 0 ? 1 : 0);
                if (remainder > 0) remainder--;
            }
            state.distributions.other = 0;
        } else { // count引数がない場合（初回起動時）は、デフォルトキャラクターを読み込む
            const defaultCount = DEFAULT_CHARACTERS.length;
            state = { charCount: defaultCount, icons: {}, distributions: {}, matchups: {}, otherMatchups: {} };
            
            let charactersDistSum = 0;
            DEFAULT_CHARACTERS.forEach((char, index) => {
                state.icons[index] = char.src;
                state.distributions[index] = Number(char.distribution);
                charactersDistSum += Number(char.distribution);
            });
            
            state.distributions.other = 100 - charactersDistSum;
            charCountInput.value = defaultCount; // キャラ数入力欄の数値を更新
            // 念のため再計算
            computeOtherDistribution();
        }
    }

    // Try to fetch remote images and convert them to data URLs to avoid CORS/tainted canvas issues.
    async function preloadPresetImages() {
        const cacheKey = 'aishou_preset_cache_v1';
        let cacheMap = {};
        try { cacheMap = JSON.parse(localStorage.getItem(cacheKey) || '{}'); } catch (e) { cacheMap = {}; }

        const convertPromises = PRESET_IMAGES.map(async (src, i) => {
            // If it's already a data URL, leave it
            if (/^data:/i.test(src)) return src;

            // For relative/local paths (img/...), prefer to leave them as-is (they work when served via HTTP).
            // If we have a cached data URL for the same original src, use it — this helps when running from file://
            if (!/^(https?:)?\/\//i.test(src)) {
                return cacheMap[src] || src;
            }

            // If we cached this remote URL before, use the cached data URL
            if (cacheMap[src]) return cacheMap[src];

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                const res = await fetch(src, { mode: 'cors', signal: controller.signal });
                clearTimeout(timeoutId);
                if (!res.ok) return src;
                const blob = await res.blob();
                const dataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onerror = () => reject(src);
                    reader.onload = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });
                // Cache the converted data URL
                try { cacheMap[src] = dataUrl; } catch (e) { /* ignore storage errors */ }
                return dataUrl;
            } catch (e) {
                // on any error, keep original src
                return src;
            }
        });

        const results = await Promise.all(convertPromises);
        // Replace PRESET_IMAGES entries with converted data URLs where available
        for (let i = 0; i < results.length; i++) PRESET_IMAGES[i] = results[i];

        // Persist cacheMap back to localStorage (best-effort)
        try { localStorage.setItem(cacheKey, JSON.stringify(cacheMap)); } catch (e) { /* ignore */ }
    }

    function createModalOptions() {
        const matchupModalContent = matchupModal.querySelector('.modal-content');
        matchupModalContent.innerHTML = '';
        // Let CSS grid place items naturally; each option shows an emoji and the percent below it
        ICONS.forEach((key) => {
            const option = document.createElement('div');
            option.className = 'modal-option';
            const label = document.createElement('div');
            label.textContent = ICON_DISPLAY[key] || DEFAULT_SYMBOL;
            label.style.fontSize = '1.6rem';
            const pct = document.createElement('div');
            const pctVal = COMPATIBILITY_MAP[key] || Number(key) || 50;
            pct.textContent = pctVal + '%';
            pct.style.fontSize = '0.85rem';
            pct.style.marginTop = '4px';
            pct.style.opacity = '0.95';
            pct.style.color = '#ffd';
            option.appendChild(label);
            option.appendChild(pct);
            option.addEventListener('click', () => handleModalSelection(key));
            matchupModalContent.appendChild(option);
        });

        const presetGrid = getEl('preset-char-grid');
        presetGrid.innerHTML = '';
        PRESET_IMAGES.forEach(src => {
            const iconDiv = document.createElement('div');
            iconDiv.className = 'preset-char-icon';
            const img = document.createElement('img');
            // Only set crossOrigin for remote images (http/https or protocol-relative).
            if (/^(https?:)?\/\//i.test(src)) img.crossOrigin = 'anonymous';
            img.src = src;
            iconDiv.appendChild(img);
            iconDiv.addEventListener('click', () => {
                if (currentEdit.type === 'icon') {
                    state.icons[currentEdit.index] = src;
                    charSelectModal.classList.remove('visible');
                    renderChart();
                }
            });
            presetGrid.appendChild(iconDiv);
        });
    }

    function renderLegend() {
        legendContainer.innerHTML = '';
        Object.entries(COMPATIBILITY_MAP).sort((a,b)=>Number(b[1])-Number(a[1])).forEach(([key, value]) => {
            const item = document.createElement('div');
            item.className = 'legend-item';
            const symbol = ICON_DISPLAY[key] || DEFAULT_SYMBOL;
            item.innerHTML = `<span>${symbol}</span>: <span>${value}%</span>`;
            legendContainer.appendChild(item);
        });
    }

    function renderChart() {
        chartContainer.innerHTML = '';
        const { charCount } = state;
        const gridColumns = charCount + 3;
        chartContainer.style.gridTemplateColumns = `repeat(${gridColumns}, var(--cell-size))`;

        chartContainer.appendChild(createCell({ text: '分布', className: 'header-text' }));
        for (let i = 0; i < charCount; i++) chartContainer.appendChild(createDistributionCell(i));
        chartContainer.appendChild(createDistributionCell('other'));
        chartContainer.appendChild(createCell({}));
        updateTotalDistribution();

        chartContainer.appendChild(createCell({}));
        for (let i = 0; i < charCount; i++) chartContainer.appendChild(createIconCell(i));
        chartContainer.appendChild(createCell({ text: 'その他', className: 'header-text' }));
        chartContainer.appendChild(createCell({ text: '総合勝率', className: 'header-text' }));

        for (let r = 0; r < charCount; r++) {
            chartContainer.appendChild(createIconCell(r, true));
            for (let c = 0; c < charCount; c++) chartContainer.appendChild(createMatchupCell(r, c));
            chartContainer.appendChild(createOtherMatchupCell(r));
            chartContainer.appendChild(createWinRateCell(r));
        }
    }

    function updateTotalDistribution() {
        const total = Object.values(state.distributions).reduce((sum, val) => sum + Number(val || 0), 0);
        distTotalEl.textContent = `合計分布: ${total.toFixed(0)}%`;
        distTotalEl.classList.toggle('error', Math.abs(total - 100) > 0.1);
    }

    // 自動で 'other' を計算して 100% になるようにする
    function computeOtherDistribution() {
        const sum = Object.entries(state.distributions).reduce((s, [k, v]) => {
            if (k === 'other') return s;
            return s + Number(v || 0);
        }, 0);
        const otherVal = Math.max(0, 100 - sum);
        state.distributions.other = otherVal;
    }

    function createCell({ text = '', className = '', content, onClick } = {}) {
        const cell = document.createElement('div');
        cell.className = `grid-cell ${className}`;
        if (text) cell.textContent = text;
        if (content) cell.appendChild(content);
        if (onClick) cell.addEventListener('click', onClick);
        return cell;
    }

    function createDistributionCell(index) {
        // 'other' remains read-only and displays computed percent
        if (index === 'other') {
            const span = document.createElement('span');
            const val = (state.distributions.other !== undefined) ? Number(state.distributions.other) : 0;
            span.textContent = `${val}%`;
            span.className = 'distribution-label';
            return createCell({ content: span, className: 'other-cell' });
        }

        // Create a cell that shows the percentage text. A hidden select inside allows editing when clicked.
        const cellDisplay = document.createElement('div');
    cellDisplay.style.width = '100%';
    cellDisplay.style.height = '100%';
    cellDisplay.style.boxSizing = 'border-box';
    cellDisplay.style.overflow = 'hidden';
        cellDisplay.style.display = 'flex';
    cellDisplay.style.alignItems = 'center';
    cellDisplay.style.justifyContent = 'center';
    cellDisplay.style.paddingRight = '20px';

    const percentText = document.createElement('span');
    percentText.textContent = (state.distributions[index] !== undefined) ? `${state.distributions[index]}%` : '0%';
    percentText.style.pointerEvents = 'none';
    percentText.style.fontSize = '1.0rem';
    percentText.style.fontWeight = '700';
    percentText.style.zIndex = '2';
    percentText.style.position = 'relative';
    percentText.style.left = '0';
    percentText.style.paddingRight = '8px';
    // Always show numeric percentage fully; avoid truncation/ellipsis so numbers remain readable
    percentText.style.display = 'inline-block';
    // move the percent text slightly right so it sits nearer the select arrow
    percentText.style.maxWidth = 'calc(var(--cell-size) - 20px)';
    percentText.style.marginLeft = '6px';
    percentText.style.overflow = 'visible';
    percentText.style.textOverflow = 'clip';
    percentText.style.whiteSpace = 'nowrap';

        const select = document.createElement('select');
        select.className = 'distribution-select';
        select.style.position = 'absolute';
        select.style.opacity = '0';
        select.style.pointerEvents = 'none';
        for (let v = 0; v <= 100; v += 5) {
            const opt = document.createElement('option');
            opt.value = String(v);
            opt.textContent = String(v);
            select.appendChild(opt);
        }
        // Add a custom option at the end
        const customOpt = document.createElement('option');
        customOpt.value = 'custom';
        customOpt.textContent = 'カスタム...';
        select.appendChild(customOpt);
        select.value = String(state.distributions[index] || 0);

        select.addEventListener('change', e => {
            const raw = e.target.value;
            if (raw === 'custom') {
                const input = prompt('カスタム値を入力してください（0〜100）');
                if (input === null) { select.value = String(state.distributions[index] || 0); return; }
                const n = Number(input);
                if (isNaN(n) || n < 0 || n > 100) { alert('0〜100の数値を入力してください'); select.value = String(state.distributions[index] || 0); return; }
                state.distributions[index] = n;
                percentText.textContent = n + '%';
                computeOtherDistribution();
                renderChart();
                return;
            }
            const val = Number(raw);
            state.distributions[index] = val;
            percentText.textContent = val + '%';
            computeOtherDistribution();
            renderChart();
        });

        // Build outer cell. We'll allow two interaction zones:
        // - clicking the select arrow (we'll show the select over the right edge) opens native dropdown
        // - clicking the rest of the cell opens a numeric prompt for direct input
        const outer = createCell({ content: cellDisplay });
        cellDisplay.appendChild(percentText);

    // Create a thin vertical button at the right edge with a V-shaped icon.
    const selectWrapper = document.createElement('div');
    selectWrapper.style.position = 'absolute';
    selectWrapper.style.right = '0px';
    selectWrapper.style.top = '0px';
    selectWrapper.style.bottom = '0px';
    selectWrapper.style.width = '16px';
    selectWrapper.style.overflow = 'hidden';
    selectWrapper.style.borderRadius = '0';
    selectWrapper.style.background = 'rgba(255,255,255,0.03)';
    selectWrapper.style.borderLeft = '1px solid rgba(255,255,255,0.04)';
    selectWrapper.style.display = 'flex';
    selectWrapper.style.alignItems = 'center';
    selectWrapper.style.justifyContent = 'center';
    // Hide the native select visually (we'll trigger it programmatically) so only our V icon is visible
    select.style.opacity = '0';
    select.style.pointerEvents = 'none';
    selectWrapper.appendChild(select);

    // Custom vertical button that shows a V-shaped chevron icon
    const customBtn = document.createElement('div');
    customBtn.style.position = 'absolute';
    customBtn.style.right = '0px';
    customBtn.style.top = '0px';
    customBtn.style.bottom = '0px';
    customBtn.style.width = '16px';
    customBtn.style.display = 'flex';
    customBtn.style.alignItems = 'center';
    customBtn.style.justifyContent = 'center';
    customBtn.style.cursor = 'pointer';
    customBtn.style.background = 'transparent';
    customBtn.style.paddingRight = '2px';
    customBtn.style.borderRadius = '0';
    customBtn.setAttribute('aria-label', '分布を選択');
    // SVG V-shaped icon (down chevron style)
    customBtn.innerHTML = `<svg width="12" height="12" viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><polyline points="2,4 6,8 10,4" stroke="#fff" stroke-width="1.6" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
    // When custom button clicked, programmatically open the select
    customBtn.addEventListener('click', (ev) => {
        ev.stopPropagation();
        try {
            // Try to synthesize a mousedown which often opens the native select
            const me = new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window });
            select.dispatchEvent(me);
            select.focus();
            // As a fallback, temporarily enable pointer events and click
            setTimeout(() => {
                select.style.pointerEvents = 'auto';
                select.style.opacity = '0.01';
                select.click();
                setTimeout(() => { select.style.pointerEvents = 'none'; select.style.opacity = '0'; }, 200);
            }, 10);
        } catch (e) {
            // ignore
        }
    });
    cellDisplay.appendChild(customBtn);
    // Style the select so the arrow area is clearly visible and tappable
    select.style.opacity = '1';
    select.style.pointerEvents = 'auto';
    // Make the native select just wide enough for the native arrow — keep it minimally intrusive
    select.style.width = '18px';
    select.style.height = '100%';
    select.style.writingMode = 'vertical-rl';
    select.style.textOrientation = 'mixed';
    select.style.background = 'transparent';
    // Hide the select's text so only the native arrow is visible; keep arrow usable.
    // Hide the select's visible text reliably while keeping the native arrow visible.
    select.style.color = 'transparent';
    select.style.textShadow = 'none';
    select.style.border = 'none';
    select.style.overflow = 'hidden';
    select.style.textIndent = '9999px';
    select.style.whiteSpace = 'nowrap';
    select.style.appearance = 'menulist-button';
    select.style.webkitAppearance = 'menulist-button';
    select.style.textAlign = 'right';
    select.style.paddingRight = '6px';
    // Make the select look like a small button: hide its text but show native arrow
    selectWrapper.style.boxShadow = 'inset 0 0 0 1px rgba(255,255,255,0.02)';
    selectWrapper.style.cursor = 'pointer';
    selectWrapper.style.alignItems = 'center';
    selectWrapper.style.paddingRight = '1px';

        // Ensure percent text appears above the select visually
        percentText.style.zIndex = '2';
        selectWrapper.style.zIndex = '1';

        // Clicking the selectWrapper opens native dropdown (just focus the select)
        select.addEventListener('mousedown', e => {
            // allow default behavior to open native dropdown
            e.stopPropagation();
        });

        // Clicking the visible percent area (outer) opens a numeric prompt for direct input
        outer.addEventListener('click', (e) => {
            // If the click was inside the selectWrapper, let native select handle it
            if (e.target === select || select.contains(e.target) || selectWrapper.contains(e.target)) return;
            const input = prompt('直接値を入力してください（0〜100）', String(state.distributions[index] || 0));
            if (input === null) return;
            const n = Number(input);
            if (isNaN(n) || n < 0 || n > 100) { alert('0〜100の数値を入力してください'); return; }
            state.distributions[index] = n;
            percentText.textContent = n + '%';
            computeOtherDistribution();
            renderChart();
        });

        cellDisplay.appendChild(selectWrapper);
        return outer;
    }

    function createIconCell(index, isHeader = false) {
        const iconSrc = state.icons[index];
        const content = document.createElement(iconSrc ? 'img' : 'span');
        if (iconSrc) {
            // Only set crossOrigin for remote images; local relative paths or data: should not set it
            if (/^(https?:)?\/\//i.test(iconSrc)) content.crossOrigin = 'anonymous';
            content.src = iconSrc;
        } else content.textContent = '+';
        const cell = createCell({ content, className: 'char-icon-slot' });
        // Allow editing the character by clicking the icon whether it's in the top row or the left column
        cell.addEventListener('click', () => {
            currentEdit = { type: 'icon', index };
            charSelectModal.classList.add('visible');
        });
        return cell;
    }

    function createMatchupCell(r, c) {
        // For same-character matchup, show the default icon symbol (ー) instead of a dash
        if (r === c) {
            const wrapper = document.createElement('div');
            const sym = document.createElement('div'); sym.textContent = DEFAULT_SYMBOL; sym.style.fontSize = '1.2rem';
            const pct = document.createElement('div'); pct.textContent = (COMPATIBILITY_MAP[DEFAULT_KEY] || 50) + '%'; pct.style.fontSize = '0.75rem'; pct.style.marginTop = '4px'; pct.style.opacity = '0.9'; pct.style.color = '#ffd';
            wrapper.appendChild(sym); wrapper.appendChild(pct);
            return createCell({ content: wrapper, className: 'data-cell disabled' });
        }
        const key = state.matchups[`${r}-${c}`] || DEFAULT_KEY;
        const wrapper = document.createElement('div');
        const sym = document.createElement('div'); sym.textContent = ICON_DISPLAY[key] || DEFAULT_SYMBOL; sym.style.fontSize = '1.2rem';
        const pct = document.createElement('div'); pct.textContent = (COMPATIBILITY_MAP[key] || Number(key) || 50) + '%'; pct.style.fontSize = '0.75rem'; pct.style.marginTop = '4px'; pct.style.opacity = '0.9'; pct.style.color = '#ffd';
        wrapper.appendChild(sym); wrapper.appendChild(pct);
        return createCell({ content: wrapper, className: 'data-cell', onClick: () => {
            currentEdit = { type: 'matchup', row: r, col: c };
            matchupModal.classList.add('visible');
        }});
    }
    
    function createOtherMatchupCell(r) {
        const key = state.otherMatchups[r] || DEFAULT_KEY;
        const wrapper = document.createElement('div');
        const sym = document.createElement('div'); sym.textContent = ICON_DISPLAY[key] || DEFAULT_SYMBOL; sym.style.fontSize = '1.0rem';
        const pct = document.createElement('div'); pct.textContent = (COMPATIBILITY_MAP[key] || Number(key) || 50) + '%'; pct.style.fontSize = '0.75rem'; pct.style.marginTop = '4px'; pct.style.opacity = '0.9'; pct.style.color = '#ffd';
        wrapper.appendChild(sym); wrapper.appendChild(pct);
        return createCell({ content: wrapper, className: 'data-cell other-cell', onClick: () => {
            currentEdit = { type: 'otherMatchup', row: r };
            matchupModal.classList.add('visible');
        }});
    }

    function createWinRateCell(r) {
        let weightedSum = 0, totalDist = 0;
        Object.entries(state.distributions).forEach(([key, distStr]) => {
            const dist = parseFloat(distStr || 0);
            if (dist <= 0) return;
            let icon;
            if (key === 'other') {
                icon = state.otherMatchups[r] || DEFAULT_KEY;
            } else {
                const c = parseInt(key, 10);
                if (r === c) return;
                icon = state.matchups[`${r}-${c}`] || DEFAULT_KEY;
            }
            weightedSum += (COMPATIBILITY_MAP[icon] || Number(icon) || 50) * dist;
            totalDist += dist;
        });
        const winRateText = totalDist > 0 ? `${(weightedSum / totalDist).toFixed(1)}%` : '-%';
        return createCell({ text: winRateText, className: 'win-rate-cell' });
    }

    function handleModalSelection(icon) {
        const { type, row, col } = currentEdit;
        if (type === 'matchup') {
            // 'icon' here is the key (e.g. '70'). Store keys in state.
            state.matchups[`${row}-${col}`] = icon;
            const oppositeVal = 100 - (COMPATIBILITY_MAP[icon] || Number(icon) || 50);
            const oppositeIcon = Object.keys(COMPATIBILITY_MAP).find(key => (COMPATIBILITY_MAP[key] || Number(key)) === oppositeVal) || DEFAULT_KEY;
            state.matchups[`${col}-${row}`] = oppositeIcon;
        } else if (type === 'otherMatchup') {
            state.otherMatchups[row] = icon;
        }
        matchupModal.classList.remove('visible');
        renderChart();
    }

    function start() {
        // Preload/convert preset images when possible, then initialize state
        (async () => {
            await preloadPresetImages();
            initializeState(); // 引数なしで呼び出し、デフォルトキャラクターを読み込む
            createModalOptions();
            renderLegend();
            renderChart();
        })();
    }
    start();
});
</script>
</body>
</html>

